package uhh_lt.datenbank;

import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.HttpSolrClient;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.common.SolrDocument;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrInputDocument;
import org.json.simple.JSONObject;
import uhh_lt.webserver.Datendifferenzberechner;
import uhh_lt.webserver.JsonImport2;

import java.io.*;
import java.util.*;

import static java.lang.Math.toIntExact;
import static java.lang.String.valueOf;
import static junit.framework.Assert.assertEquals;

public class SolrConnect
{
    private static SolrClient client;
    private JsonImport jsonImport;

    public SolrConnect()
    { // für ssh  : localhost , sonst ltdemos:8983/solr/fea-schema-less-2
         client = new HttpSolrClient.Builder("http://ltdemos:8983/solr/fea-schema-less-2").build();
         jsonImport = new JsonImport();
    }

    /**
     * Liest Daten in die Solr Datenbank ein
     * @param object Ein JSON Object
     * @param commit Wenn true wird committed
     */
    public void store(JSONObject object, boolean commit)
    {
        SolrInputDocument inputDocument = new SolrInputDocument();
        inputDocument.addField("id", object.get("Topic_id"));
        String tDate = (String) object.get("T_Date");
        inputDocument.addField("t_date", tDate);
        inputDocument.addField("t_subject", object.get("T_Subject"));
        inputDocument.addField("price", object.get("T_Price"));
        inputDocument.addField("t_message", object.get("T_Message"));
        inputDocument.addField("t_summary", object.get("T_Summary"));
        inputDocument.addField("a_date", object.get("R_posted"));
        inputDocument.addField("a_message", object.get("R_Message"));
        inputDocument.addField("t_time", Datendifferenzberechner.Differenz((String)object.get("T_Date"),(String)object.get("R_posted")));


        try {
            client.add(inputDocument);
            if (commit) {
                client.commit();
            }
        }
        catch (SolrServerException | IOException e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Committed Daten in die Solr Datenbank
     */
    public void commit() {
        try {
            client.commit();
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Führt eine Datenbankanfrage durch
     * @param searchTerm Ein Suchbegriff
     * @return die Datenbankeinträge zu einem gegebenen Suchbegriff werden ausgegeben
     */
    public String search(String searchTerm)
    {
        SolrQuery query = new SolrQuery();
        query.setQuery(searchTerm);
        query.setFields("id");
        query.setStart(0);
        QueryResponse response = null;
        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
        StringBuilder out = new StringBuilder();
        assert response != null;
        SolrDocumentList results = response.getResults();
        for (SolrDocument result : results) {
            out.append(result).append("\n");
        }
        return out.toString();
    }


    /**
     * Holt die Kundenfrage zu einer gegebenen ID aus der Datenbank
     * @param id Die ID eines Datenbankeintags
     * @return die Kundenanfrage zu der gegebenen ID
     */
    public String getFrage(String id) {
    SolrQuery query = new SolrQuery();
    query.setQuery("id:" + id).setFields("t_message").setStart(0).setRows(10000);
    QueryResponse response = null;

        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList results = response.getResults();
        return valueOf(results.get(0).get("t_message"));
    }

    public String getPreis(String id) {
        SolrQuery query = new SolrQuery();
        query.setQuery("id:" + id).setFields("price").setStart(0).setRows(10000);

        QueryResponse response = null;

        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList results = response.getResults();
        Object doc;
        ArrayList<Object> array1 = new ArrayList<>();
        for (SolrDocument document : results) {
            doc = ((List)document.getFieldValue("price")).get(0);
            array1.add(doc);
        }
        return valueOf(array1).replace("[", "").replace("]", "");

    }

    /**
     * Erstellt ein Textfile mit allen IDs
     */
    public void printIdInDoc() throws IOException
    {
        SolrQuery query = new SolrQuery();
        query.setQuery("*:*").setFields("id").setStart(0).setRows(10000);
        QueryResponse response = null;

        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList results = response.getResults();
        FileWriter fw = new FileWriter("resources/outputID.txt");
        for (SolrDocument result : results) {
            System.out.println(result);
            fw.write(valueOf(result.get("id")));
            fw.write("\n");
        }
        fw.close();
    }

    /**
     * Der SolrUpdater fügt der Datenbank eine neues Feld Rechtsexperten_istmieter hinzu
     * @param  docID die ID, den Primärschlüssel, als String
     * @param  istMieter wenn es sich um einen Mieter handelt true, sonst false
     */
    void addRechtsexpertenfeldMieter(String docID, Object istMieter)
    {
        addField(docID, "Rechtsexperten_istmieter", istMieter);
    }


    /**
     * Es wird ein neues Feld in Solr erzeugt und mit einem eingegebenen Wert gefüllt
     * @param docID die DokumentenID, der Primärschlüssel
     * @param fieldName der Name des Feldes als String
     * @param object der Wert, der dem Feld hinzugefügt werden soll
     */
    void addField(String docID, String fieldName, Object object)
    {
        SolrQuery query = new SolrQuery();
        query.set("q", "id:"+ docID);
        QueryResponse response = null;
        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList docList = response.getResults();
        assertEquals(docList.getNumFound(), 1);
        for (SolrDocument doc : docList)
        {
            assertEquals((String) doc.getFieldValue("id"), docID);
        }

        SolrDocument oldDoc = response.getResults().get(0);
        SolrInputDocument inputDocument = new SolrInputDocument();
        Collection<String> feldnamensliste = oldDoc.getFieldNames();
        ArrayList<String> list = new ArrayList<>();
        list.addAll(feldnamensliste);

        for (String s : list) {
            inputDocument.addField(s, oldDoc.getFieldValue(s));
        }

        inputDocument.addField(fieldName, object);
        try {
            client.add(inputDocument);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        try {
            client.commit();
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Es können gezielt Felder per ID in der Datenbank aufgerufen und verändert werden
     * @param fieldName Ein Feldnamen
     * @param docID Eine ID als String
     * @param object Eine zu setzende Änderunng
     **/

    public void changeValueByField(String docID, String fieldName, Object object)
    {
        SolrQuery query = new SolrQuery();
        query.set("q", "id:"+docID);
        QueryResponse response = null;
        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList docList = response.getResults();
        assertEquals(docList.getNumFound(), 1);
        for (SolrDocument doc : docList)
        {
            assertEquals((String) doc.getFieldValue("id"), docID);
        }

        SolrDocument oldDoc = response.getResults().get(0);
        SolrInputDocument inputDocument = new SolrInputDocument();
        Collection<String> feldnamensliste = oldDoc.getFieldNames();
        ArrayList<String> list = new ArrayList<>();
        list.addAll(feldnamensliste);

        for (String s : list) {
            inputDocument.addField(s, oldDoc.getFieldValue(s));
        }

        inputDocument.getField(fieldName).setValue(object, 1.0f);
        try {
            client.add(inputDocument);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        try {
            client.commit();
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Die Methode liest die Textdatei "outputID.txt" ein und gibt eine Arrayliste zurück
     * @return gibt eine Arraylist mit allen IDs zurück
     */
    public ArrayList idEinleser()
    {
        ArrayList arrayList = new ArrayList();

        InputStream input = getClass().getClassLoader().getResourceAsStream("outputID.txt");

        BufferedReader TSVFile = null;
        try {
            assert input != null;
            TSVFile = new BufferedReader(
                    new InputStreamReader(input));
            String dataRow = null; // Read first line

            try {
                dataRow = TSVFile.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            while (dataRow != null)
            {
                String data = dataRow.trim();
                if (!data.isEmpty())
                {
                    arrayList.add(data);
                }
                dataRow = TSVFile.readLine(); // Read next line of data.
            }
            TSVFile.close();
        }catch (FileNotFoundException e) {
            System.err.println("Die Datei konnte nicht geöffnet werden");
        } catch (IOException e) {
            e.printStackTrace();
        }
        return arrayList;
    }

    /**
     * Die Methode gibt die entsprechende Frage zu einer gegebenen ID zurück, um sie für Klassifikationen einlesen
     * zu können
     * @param docId die DokumentenID, der Primärschlüssel
     * @return gibt die Kundenanfrage zu einer gegebenen ID zurück
     */
    public Object fragenAusgeber(String docId)
    {
        SolrQuery query = new SolrQuery();
        query.set("q", "id:"+docId);
        QueryResponse response = null;
        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList docList = response.getResults();
        assertEquals(docList.getNumFound(), 1);
        for (SolrDocument doc : docList)
        {
            assertEquals((String) doc.getFieldValue("id"), docId);
        }

        SolrDocument oldDoc = response.getResults().get(0);
        Object question = oldDoc.getFieldValue("t_message");
        return question;
    }


    /**
     * Anhand einer ID wird das JSON-Objekt aus Solr gelöscht
     * @param docID eine ID als String
     */
    public void solrDeleteByID(String docID)
    {
        try {
            client.deleteById(docID);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
        try {
            client.commit();
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
    }


    /**
     * Eine allgemeine Methode um die Anzahl an Übereinstimmungen zwischen den Listen oder Watson mit den
     * Rechtsexperten zu erhalten
     * @param fieldname ein Watson- oder ein Expertensystemfeld
     * @param param1 einen true- oder false-Wert zu dem fieldnamen
     * @param param2 ein true- oder false-Wert zu dem Rechtsexperten_istmieter-Feld
     * @return gibt die Zahl der übereinstimmenden Fälle an
     */
    int getUebereinstimmung(String fieldname, Object param1, Object param2)
    {
        SolrQuery query = new SolrQuery();
        query.set("q", ""+fieldname+":"+param1+" AND "+"Rechtsexperten_istmieter"+":"+param2);
        query.setRows(10001);
        QueryResponse response = null;
        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }
        assert response != null;
        SolrDocumentList results = response.getResults();
        long key = results.getNumFound();
        int keyInt = toIntExact(key);
        return keyInt;
    }

    /**
     * Die Methode nimmt einen Feldnamen entgegen und vergleicht ihn mit dem Feld "Preis"
     * @param fieldName Nimmt einen Feldnamen entgegen, um den Wert des Feldes dem Feld "Preis" zu vergleichen
     * @return gibt einen aufsteigend geordneten String im Format [eines Feldwert, Preis] ... zurück
     */
    String comparer(String fieldName) {
        StringBuilder sb = new StringBuilder();
        SolrQuery query = new SolrQuery();
        query.set("q", "*:*");
        query.setRows(10001);
        QueryResponse response = null;
        try {
            response = client.query(query);
        } catch (SolrServerException | IOException e) {
            e.printStackTrace();
        }

        assert response != null;
        SolrDocumentList results = response.getResults();
        Object doc;
        Object doc1;
        ArrayList<Object> array1 = new ArrayList<>();
        ArrayList<Object> array2 = new ArrayList<>();
        for (SolrDocument document : results) {
            doc = ((List)document.getFieldValue(fieldName)).get(0);
            array1.add(doc);
            doc1 = ((List)document.getFieldValue("price")).get(0);
            array2.add(doc1);
        }

        HashMap<Integer, String> hmap = new HashMap<>();
        for(int i=0;i<array1.size(); i++)
        {
            int key = Integer.valueOf((array1.get(i)).toString());
            hmap.put(key, array2.get(i).toString());
        }

        hmap = removeXValuesFromHashMap(30, hmap);

        Map<Integer, String> map = new TreeMap<>(hmap);
        Set set2 = map.entrySet();
        Iterator iterator2 = set2.iterator();
        while(iterator2.hasNext()) {
            Map.Entry me2 = (Map.Entry)iterator2.next();
            sb.append("[" + me2.getKey() + "," + me2.getValue()+ "],");
        }
        return sb.toString().substring(0,sb.length()-1);
    }

    /**
     * Entfernt eine eingegebene Anzahl an höchsten Werten aus einer Hashmap zur Entfernung von Ausreißern
     * @param anzahl eine Anzahl an zu entfernenden Werten
     * @param hmap eine Hashmap
     * @return die um die gegebene Anzahl reduzierte Hashmap
     */
    private HashMap removeXValuesFromHashMap(int anzahl, HashMap hmap)
    {
        Iterator<Integer> iterator = hmap.keySet().iterator();

        for(int i= 0; i<=anzahl;i++)
        {
            iterator =hmap.keySet().iterator();
            int value = 0;
            int tmp;
            while (iterator.hasNext())
            {
                tmp = iterator.next();
                if (tmp > value)
                {
                    value = tmp;
                }
            }
            hmap.remove(value);
        }
        return hmap;
    }

}